module baseCpl
use proc_def 
use comms_def
use procm, only: pm_init => init, clean
use comms
use timeM
use mct_mod
#for comp in $comp_set
use comp_${comp}
#end for

     implicit none
     type(proc), target :: my_proc
     ## comp interprete comp_model
     #for comp in $comp_set
     type(gsMap)   :: gsMap_${comp}${comp}
     type(gsMap)   :: gsMap_${comp}x
     #end for

     #for comp in $comp_set
     type(AttrVect),pointer   :: ${comp}2x_${comp}${comp}
     type(AttrVect),pointer   :: x2${comp}_${comp}${comp}
     type(AttrVect),pointer   :: ${comp}2x_${comp}x
     type(AttrVect),pointer   :: x2${comp}_${comp}x
     #end for

    #for comp in $comp_set
            #for comp_t in $comp_set
                #if comp_t == comp:
                    #continue
                #end if
                type(AttrVect)  :: ${comp}2x_${comp_t}x
            #end for
    #end for

     #for comp in $comp_set
     logical :: ${comp}_run
     #end for
    
    logical :: stop_clock
    type(clock) :: EClock
 
     public :: cpl_init
     public :: cpl_run
     public :: cpl_final

contains

subroutine cpl_init()
    implicit none
    integer :: ierr
    integer :: comm_rank
    call pm_init(my_proc)
    call clock_init(EClock)
    
    !---
    !A in 0,1,gsize=8   B in 2,3,gsize=12   C in 2,3,gsize=16
    !cpl in 0,1,2,3
	
    !-------------------------------------------------------------------
    ! variables comp2x_yy point to 
    !  !TODO add comments
    !-------------------------------------------------------------------
    #for comp in $comp_set
    ${comp}2x_${comp}${comp} => my_proc%${comp}2x_${comp}${comp}
    ${comp}2x_${comp}x => my_proc%${comp}2x_${comp}x
    x2${comp}_${comp}${comp} => my_proc%x2${comp}_${comp}${comp}
    x2${comp}_${comp}x => my_proc%x2${comp}_${comp}x
    #end for

    !-------------------------------------------------------------------
    ! !TODO add comments
    !-------------------------------------------------------------------
    call MPI_Comm_rank(MPI_COMM_WORLD, comm_rank, ierr)
    #for comp in $comp_set
    if(my_proc%iamin_model${comp})then
        write(*,*)'a Init: Im:', comm_rank
        call ${comp}_init_mct(my_proc, my_proc%model${comp}_id, EClock, gsMap_${comp}${comp}, &
                              ${comp}2x_${comp}${comp}, x2${comp}_${comp}${comp}, ierr)
    end if
    #end for
    
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
            write(*,*) '<<==== All Model Init Rank:', comm_rank, " Over ====>>"
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
            write(*,*) ' '
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
    
    #for comp in $comp_set
    if(my_proc%iamin_model${comp}2cpl)then
        call gsmap_init_ext(my_proc, gsmap_${comp}${comp}, my_proc%model${comp}_id, gsmap_${comp}x, &
                            my_proc%cplid, my_proc%model${comp}2cpl_id )

        call avect_init_ext(my_proc, ${comp}2x_${comp}${comp},&
my_proc%model${comp}_id, ${comp}2x_${comp}x, &
                            my_proc%cplid, gsmap_${comp}x, my_proc%model${comp}2cpl_id)

        call avect_init_ext(my_proc, x2${comp}_${comp}${comp},&
my_proc%model${comp}_id, x2${comp}_${comp}x, &
                            my_proc%cplid, gsmap_${comp}x, my_proc%model${comp}2cpl_id)

        call MPI_Barrier(my_proc%mpi_model${comp}2cpl, ierr)
            write(*,*) '<<========Model${comp}2X Rank:', comm_rank,  &
"${comp}x_lsize:", avect_lsize(${comp}2x_${comp}x),"&
${comp}${comp}_lsize:", avect_lsize(${comp}2x_${comp}${comp}),&
            ' ===========>>'
        call MPI_Barrier(my_proc%mpi_model${comp}2cpl, ierr)

        call MPI_Barrier(my_proc%mpi_model${comp}2cpl, ierr)
            write(*,*) '<<========Model${comp}2X Rank:', comm_rank,  'AV GSMap Init Over ===========>>'
        call MPI_Barrier(my_proc%mpi_model${comp}2cpl, ierr)

        call mapper_rearrsplit_init(my_proc%mapper_C${comp}2x, my_proc, gsmap_${comp}${comp}, my_proc%model${comp}_id, &
                                    gsmap_${comp}x, my_proc%cplid, my_proc%model${comp}2cpl_id, ierr)

        call mapper_rearrsplit_init(my_proc%mapper_Cx2${comp}, my_proc, gsmap_${comp}x, my_proc%cplid, &
                                    gsmap_${comp}${comp}, my_proc%model${comp}_id, my_proc%model${comp}2cpl_id, ierr)

        call MPI_Barrier(my_proc%mpi_model${comp}2cpl, ierr)
        call mapper_comp_map(my_proc%mapper_C${comp}2x, ${comp}2x_${comp}${comp}, ${comp}2x_${comp}x, 100+10+1, ierr)
    end if
    #end for    


    call MPI_Barrier(MPI_COMM_WORLD, ierr)
    write(6,*) '<<========= Rank:',comm_rank,' Model-XInit End====>>'
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
            write(*,*) ' '
    call MPI_Barrier(MPI_COMM_WORLD, ierr)

    if(my_proc%iamin_cpl) then
        #for comp in $comp_set
            #for comp_t in $comp_set
                #if comp_t == comp:
                    #continue
                #end if
                
                call avect_init_ext(my_proc, ${comp}2x_${comp}x, my_proc%cplid, &
                            ${comp}2x_${comp_t}x, my_proc%cplid, &
                            gsmap_${comp_t}x, my_proc%model${comp_t}2cpl_id)

                call mapper_spmat_init(my_proc,&
my_proc%mapper_SMat${comp}2${comp_t}, &
                my_proc%cplid, &
                my_proc%${comp_t}_gsize, my_proc%${comp}_gsize, 8,&
                gsmap_${comp}x, gsmap_${comp_t}x)

            #end for
        #end for
        call MPI_Barrier(MPI_COMM_WORLD, ierr)
        write(*,*) "<<=== Rank:" , comm_rank, &
            " lb2x_ax:", avect_lsize(b2x_ax),&
            " lc2x_ax:", avect_lsize(c2x_ax),&
            " la2x_bx:", avect_lsize(a2x_bx),&
            " lc2x_bx:", avect_lsize(c2x_bx),&
            " la2x_cx:", avect_lsize(a2x_cx),&
            " lb2x_cx:", avect_lsize(b2x_cx),&
            "===>>"
        call MPI_Barrier(MPI_COMM_WORLD, ierr)
        write(*,*) " "
        call MPI_Barrier(MPI_COMM_WORLD, ierr)

    end if    

    write(*,*)'init end'
    call MPI_Barrier(MPI_COMM_WORLD, ierr)

end subroutine cpl_init

subroutine cpl_run()

    implicit none
    integer :: ierr,s,i,comm_rank
    
    call mpi_comm_rank(my_proc%comp_comm(my_proc%gloid), comm_rank, ierr)
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
    write(*,*) '<<============== Rank:',comm_rank,' Begin Run==================>>'
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
            write(*,*) ' '
    call MPI_Barrier(MPI_COMM_WORLD, ierr)
    s = 0

    call triger(EClock, stop_clock, "stop_clock")
    do while(.not. stop_clock)

        call clock_advance(EClock)
        #for comp in $comp_set
        call triger(EClock, ${comp}_run, "${comp}_run")
        #end for
        call triger(EClock, stop_clock, "stop_clock")
        s = s+1
        if(s==10) stop_clock = .true.



        !------------------------------------------------------------
        !  Run phase 1 X2M_MX --> X2M_MM
        !  (M is Model, X is CPL)
        !------------------------------------------------------------

        #for comp in $comp_set
        if(${comp}_run)then
            if(my_proc%iamin_model${comp}2cpl)then
                    if(s == 3 .and. my_proc%iamin_modela2cpl) then
                        do i=1,avect_lsize(x2a_ax)
                        x2a_ax%rAttr(1,i) = x2a_ax%rAttr(1,i) + (comm_rank+1)*10+i
                        enddo
                    endif
                    if(s == 7 .and. my_proc%iamin_modelb2cpl) then
                        do i=1,avect_lsize(x2b_bx)
                            x2b_bx%rAttr(1,i) = x2b_bx%rAttr(1,i) + (comm_rank+1)*10+i
                        enddo
                    endif
                    
                    call mapper_comp_map(my_proc%mapper_Cx2${comp}, x2${comp}_${comp}x, x2${comp}_${comp}${comp}, 100+10+2, ierr)
                
                if(s == 3 .and. my_proc%iamin_modela2cpl) then
                    call MPI_Barrier(my_proc%comp_comm(my_proc%modela2cpl_id), ierr)
                    write(*,*) '<<===X2A_AA_VALUE Rank:',comm_rank, x2a_aa%rAttr(1,:)
                call MPI_Barrier(my_proc%comp_comm(my_proc%modela2cpl_id), ierr)
                end if
            end if
        end if
        #end for

        call MPI_Barrier(MPI_COMM_WORLD, ierr)


        !------------------------------------------------------------
        !  Run phase 2, Model Run,  X2M_MM --> M2X_MM
        !  (M is Model, X is CPL)
        !------------------------------------------------------------

        #for comp in $comp_set
        if(${comp}_run)then
            if(my_proc%iamin_model${comp})then
                call ${comp}_run_mct(my_proc, my_proc%model${comp}_id, EClock, ${comp}2x_${comp}${comp}, x2${comp}_${comp}${comp}, ierr)
            end if
        end if
        #end for

        call MPI_Barrier(MPI_COMM_WORLD, ierr)
                    write(*,*)
        call MPI_Barrier(MPI_COMM_WORLD, ierr)

        !------------------------------------------------------------
        !  Run phase 3
        !  For each Model:
        !  Step1: Rearrange, M2X_MM --> M2X_MX
        !  Step2: SparseMul With Other Model, M2X_MX --> M2X_BX
        !  (M is Model, X is CPL, B is Another Model)
        !------------------------------------------------------------
        !  For example:
        ! rearrage(a2x_aa,b2x_bb,c2x_cc) => (a2x_ax,b2x_bx,c2x_cx)
        ! sparse(a2x_ax b2x_bx c2x_cx) =>
        ! (a2x_bx,a2x_cx) (b2x_cx,b2x_a2) (c2x_ax,c2x_bx)
        !
   
        #for comp in $comp_set
        if(${comp}_run)then
            if(my_proc%iamin_model${comp}2cpl)then
                call mapper_comp_map(my_proc%mapper_C${comp}2x,&
${comp}2x_${comp}${comp}, ${comp}2x_${comp}x, 100+10+3, ierr)
                #for comp_t in $comp_set
                    #if comp_t == comp
                        #continue
                    #end if
                    call mapper_comp_map(&
                my_proc%mapper_SMat${comp}2${comp_t}, ${comp}2x_${comp}x, &
            ${comp}2x_${comp_t}x, 100+10+3, ierr, "x")
                #end for
            end if
        end if
        #end for
        !------------------------------------------------------------
        !  Run phase 4
        !  Merge (A2X_MX, B2X_MX, C2X_MX, M2X_MX)--> X2M_MX
        !  (M is Model, X is CPL, A,B,C is Another Model)
        !------------------------------------------------------------
        ! For Example:
        ! (c2x_ax,b2x_ax,a2x_ax) => (x2a_ax)
        ! (c2x_bx,b2x_bx,a2x_bx) => (x2b_bx)
        ! (c2x_cx,b2x_cx,a2x_cx) => (x2c_cx)
        if(s==10) then
            ! merge *2x_ax --> x2a_ax in rfield "x", cal the mean of all
            call mapper_comp_avMerge(a2x_ax, b2x_ax, c2x_ax, x2a_ax, "x")
            call MPI_Barrier(my_proc%comp_comm(my_proc%modela2cpl_id), ierr)
                    write(*,*) '<<===X2A_AX_Merge_VALUE Rank:',comm_rank, x2a_ax%rAttr(1,:)
            call MPI_Barrier(my_proc%comp_comm(my_proc%modela2cpl_id), ierr)
        endif
    end do

end subroutine cpl_run

subroutine cpl_final()

    implicit none

    !----------------------------------------------------------------------
    !     end component
    !----------------------------------------------------------------------
    #for comp in $comp_set
    if(my_proc%iamin_model${comp})then
         call ${comp}_final_mct()
    end if
    #end for

    call clean(my_proc)

end subroutine cpl_final

end module baseCpl
